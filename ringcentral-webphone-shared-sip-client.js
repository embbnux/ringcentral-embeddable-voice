!function(){"use strict";var t,e,s={981103:function(t,e,s){var i=s(446221),r=s(220961),n=s(610098),o=s(983336),a=s(361733),c=s(470529),h=s(402443);const u=new class{log(t){for(var e=arguments.length,s=new Array(e>1?e-1:0),i=1;i<e;i++)s[i-1]=arguments[i];console.log("[INFO] ",t,...s)}warn(t){for(var e=arguments.length,s=new Array(e>1?e-1:0),i=1;i<e;i++)s[i-1]=arguments[i];console.warn("[WARN] ",t,...s)}error(t){for(var e=arguments.length,s=new Array(e>1?e-1:0),i=1;i<e;i++)s[i-1]=arguments[i];console.error("[ERROR] ",t,...s)}};class d extends i.A{constructor(t){let{sipInfo:e}=t;if(super(),this.wsc=void 0,this.logger=void 0,this.status="disconnected",this.wsServers=[],this.currentServer=null,this.connectTimeoutHandle=void 0,this._connectPromise=null,this.reconnectionAttempts=0,this.maxReconnectionAttempts=10,this.reconnectionTimeout=4,this.connectionTimeout=5,this.onMessage=void 0,this.onClose=void 0,this.reconnectTimeoutHandle=void 0,this.logger=u,this.currentServer=null,this.reconnectionAttempts=0,this.maxReconnectionAttempts=1===this.wsServers.length?15:10,this.reconnectionTimeout=1===this.wsServers.length?10:4,this.connectionTimeout=5,e.outboundProxy&&this.wsServers.push({server:e.outboundProxy,isError:!1,backup:!1}),e.outboundProxyBackup&&this.wsServers.push({server:e.outboundProxyBackup,isError:!1,backup:!0}),0===this.wsServers.length)throw new Error("No available servers");this.onMessage=t=>{this.emit("message",t)},this.onClose=()=>{this.wsc.removeEventListener("message",this.onMessage),this.wsc.removeEventListener("close",this.onClose),this.wsc=null,this.currentServer=null,this.reconnectionAttempts=0,this.logger.log("Transport closed"),this.setStatus("disconnected")}}setStatus(t){this.status=t,this.emit("status",t)}async connect(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._connectPromise)return this._connectPromise;try{this._connectPromise=this._connect(t),await this._connectPromise,this.setStatus("connected"),this._connectPromise=null}catch(t){this.logger.error("Connect failed",t),this.setStatus("reconnecting"),this._connectPromise=null,await this.reconnect()}}async _connect(t){const e=this.currentServer||this.getNextServer(t);if(!e)throw new Error("No available servers");if("disconnected"!==this.status&&this.wsc&&(this.logger.warn("Attempted to connect while connected, disconnecting"),await this.disconnect()),this.setStatus("connecting"),this.wsc=new WebSocket("wss://"+e.server,"sip"),this.debug){const t=this.wsc.send.bind(this.wsc);this.wsc.send=e=>(this.logger.log(`Sending...(${new Date})\n`+e),t(e))}return new Promise(((t,e)=>{const s=()=>{this.wsc.removeEventListener("open",s),this.wsc.removeEventListener("error",i),clearTimeout(this.connectTimeoutHandle),this.wsc.addEventListener("message",this.onMessage),this.wsc.addEventListener("close",this.onClose),t()},i=t=>{this.wsc.removeEventListener("error",i),this.wsc.removeEventListener("message",this.onMessage),clearTimeout(this.connectTimeoutHandle),e(t)};this.connectTimeoutHandle=setTimeout((()=>{this.wsc.close(),this.wsc.removeEventListener("open",s),this.wsc.removeEventListener("error",i),this.wsc.removeEventListener("message",this.onMessage),e(new Error("Connection timeout"))}),1e3*this.connectionTimeout),this.wsc.addEventListener("open",s),this.wsc.addEventListener("error",i)}))}getComputeRandomTimeout(t,e,s){return Math.floor(Math.random()*Math.abs(s-e))+e+(t-1)*(e+s)/2}async reconnect(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.reconnectionAttempts>0&&this.logger.warn("Reconnect attempt",this.reconnectionAttempts),t)return await this.disconnect(),this.currentServer=this.getNextServer(!0),this.reconnectionAttempts=0,void await this.connect();if(this.noAvailableServers())return this.logger.warn("No available servers"),this.setStatus("error"),this.reconnectionAttempts=0,void(this.currentServer=this.getNextServer(!0));if("reconnecting"!==this.status&&"disconnected"!==this.status&&this.wsc)return this.logger.warn("Attempted to reconnect while connected, disconnecting"),await this.disconnect(),void await this.reconnect();this.reconnectionAttempts++;const e=this.getComputeRandomTimeout(this.reconnectionAttempts,1e3*(this.reconnectionTimeout-2),1e3*(this.reconnectionTimeout+2));if(this.reconnectionAttempts>this.maxReconnectionAttempts)return this.logger.warn("Max reconnection attempts reached for server",this.currentServer.server),this.currentServer.isError=!0,this.reconnectionAttempts=0,this.currentServer=this.getNextServer(),void await this.reconnect();this.logger.warn("Reconnect attempt",this.reconnectionAttempts,"next reconnect in",e),this.reconnectTimeoutHandle&&clearTimeout(this.reconnectTimeoutHandle),this.reconnectTimeoutHandle=setTimeout((()=>{this.connect()}),e)}disconnect(){"disconnected"!==this.status&&this._disconnect()}_disconnect(){this.wsc&&(this.logger.log("Disconnecting"),this.setStatus("disconnecting"),this.wsc.close(),this.currentServer=null,this.reconnectionAttempts=0)}noAvailableServers(){for(const t of this.wsServers)if(!t.isError)return!1;return!0}getNextServer(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])return this.wsServers[0];for(const t of this.wsServers)if(!t.isError)return t;return this.wsServers[0]}dispose(){this.removeAllListeners(),this.reconnectTimeoutHandle&&clearTimeout(this.reconnectTimeoutHandle),this._disconnect(),this.currentServer=null,this.reconnectionAttempts=0}}class g extends i.A{constructor(){let{debug:t=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this.transport=void 0,this.logger=void 0,this.sipInfo=void 0,this.device=void 0,this.instanceId=void 0,this.debug=void 0,this.status="unregistered",this.clientId=void 0,this.timeoutHandle=void 0,this.debug=t,this.status="unregistered",this.logger=u}setStatus(t,e){this.status=t,this.emit("status",t,null==e?void 0:e.message)}async start(t){let{sipInfo:e,instanceId:s,device:i,clientId:o,force:a=!1,debug:h}=t;!this.transport||this.sipInfo.authorizationId!==e.authorizationId||this.sipInfo.domain!==e.domain||this.sipInfo.username!==e.username||this.sipInfo.password!==e.password||this.sipInfo.outboundProxy!==e.outboundProxy||this.sipInfo.outboundProxyBackup!==e.outboundProxyBackup||"registered"!==this.status&&"registering"!==this.status||this.clientId!==o||a?(this.logger.log("Starting SipClient"),this.sipInfo=e,this.device=i,this.instanceId=null!=s?s:e.authorizationId,this.debug=h||!1,this.clientId=o,this.transport&&(this.logger.warn("There is a transport, disposing it"),this.transport.dispose()),this.logger.log("Creating new transport"),this.transport=new d({sipInfo:e}),this.transport.on("message",(async t=>{const e=n.A.fromString(t.data);if(e.subject.startsWith("MESSAGE sip:")){const t=await r.A.fromXml(e.body);if(t.body.Cln&&t.body.Cln!==this.sipInfo.authorizationId)return}this.debug&&this.logger.log(`Receiving...(${new Date})\n`+t.data),this.emit("inboundMessage",e),(e.subject.startsWith("MESSAGE sip:")||e.subject.startsWith("BYE sip:")||e.subject.startsWith("CANCEL sip:")||e.subject.startsWith("INFO sip:")||e.subject.startsWith("NOTIFY sip:"))&&await this.reply(new c.A(e,{responseCode:200}))})),this.timeoutHandle&&clearInterval(this.timeoutHandle),this.setStatus("registering"),this.transport.on("status",(async t=>{this.logger.log("Transport status",t),this.emit("transportStatus",t),"connected"===t&&(this.logger.log("Transport connected, registering"),this.register(60))})),await this.transport.connect()):this.logger.warn("SipClient already started, current status:",this.status)}async dispose(){if("unregistered"!==this.status&&"unregistering"!==this.status){this.logger.log("Disposing SipClient");try{var t;clearTimeout(this.timeoutHandle),await this.unregister(),await(null===(t=this.transport)||void 0===t?void 0:t.dispose()),this.transport=null,this.logger.log("SipClient disposed")}catch(t){var e;return this.logger.error("SipClient dispose failed",t),this.setStatus("registrationError"),await(null===(e=this.transport)||void 0===e?void 0:e.dispose()),void(this.transport=null)}}else this.logger.warn("SipClient is already disposed, current status:",this.status)}async register(t){try{this.setStatus(t>0?"registering":"unregistering"),await this._register(t),this.setStatus(t>0?"registered":"unregistered")}catch(e){t>0?(this.logger.error("Registration failed",e),this.setStatus("registrationError",e)):this.setStatus("unregistered")}}async _register(t){const e=new a.A(`REGISTER sip:${this.sipInfo.domain} SIP/2.0`,{"Call-Id":(0,h.uR)(),Contact:`<sip:${h.K4};transport=wss>;+sip.instance="<urn:uuid:${this.instanceId}>";expires=${t}`,From:`<sip:${this.sipInfo.username}@${this.sipInfo.domain}>;tag=${(0,h.uR)()}`,To:`<sip:${this.sipInfo.username}@${this.sipInfo.domain}>`,Via:`SIP/2.0/WSS ${h.Yn};branch=${(0,h.tk)()}`,"Client-id":this.clientId}),s=new Promise(((t,s)=>{const i=setTimeout((()=>{var t;this.logger.warn("Registration timeout, disconnecting"),null===(t=this.transport)||void 0===t||t.disconnect(),s(new Error("Registration timeout"))}),8e3);this.request(e).then((e=>{this.logger.log("Registration request resolved, clearing timeout"),clearTimeout(i),t(e)})).catch((t=>{this.logger.error("Registration request rejected:",t),clearTimeout(i),s(t)}))}));this.logger.log("Sending registration request");let i=await s;this.logger.log("Received registration response");const r=i.headers["Www-Authenticate"]||i.headers["WWW-Authenticate"];if(r){const t=r.match(/, nonce="(.+?)"/)[1],s=e.fork();s.headers.Authorization=(0,h.ju)(this.sipInfo,t,"REGISTER"),i=await this.request(s)}else if(i.subject.startsWith("SIP/2.0 603 "))throw new Error("Registration failed: "+i.subject);if(t>0){const e=Number(i.headers.Contact.match(/;expires=(\d+)/)[1]);this.timeoutHandle=setTimeout((()=>{this.register(t)}),1e3*(e-3))}}async unregister(){this.logger.log("Unregistering"),await this.register(0),this.logger.log("Unregistered")}async request(t){return await this._send(t,!0)}async reply(t){await this._send(t,!1)}_send(t){let e,s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return"string"==typeof t?(this.transport.wsc.send(t),e=o.A.fromString(t)):(this.transport.wsc.send(t.toString()),e=t),this.emit("outboundMessage",e),new Promise(s?t=>{const s=i=>{i.headers.CSeq===e.headers.CSeq&&(i.subject.startsWith("SIP/2.0 100 ")||(this.off("inboundMessage",s),t(i)))};this.on("inboundMessage",s)}:t=>{t(new n.A)})}}const l=new g;let p,v=[],m={};onconnect=t=>{u.log("port onconnect");const e=t.ports[0];v.push(e),1===v.length&&(u.log("set first port as mainPort"),p=e),e.onmessage=async t=>{const{type:s,requestId:i,request:r}=t.data;if("destroyPort"===s)return u.log("destroyPort"),v=v.filter((t=>t!==e)),p===e&&(p=v[0]||null,u.log("mainPort is destroyed, set new mainPort")),void(0===v.length&&(u.log("No ports left, disposing SipClient"),await l.dispose()));if("setActive"===s){const s=t.data.activeTabId;u.log("setActive",s),p=e,v.find((t=>t===e))||(u.warn("no port found when active, add port to ports"),v.push(e)),v.forEach((t=>{t!==e&&t.postMessage({type:"setActive",activeTabId:s})}))}if("setSharedState"!==s){if("workerRequest"===s){if("getSharedState"===r.type)return void e.postMessage({type:"workerResponse",requestId:i,response:m});if("getSipClientStatus"===r.type)return void e.postMessage({type:"workerResponse",requestId:i,response:{status:l.status,sipInfo:l.sipInfo,device:l.device,instanceId:l.instanceId}});if("startSipClient"===r.type)return p||(u.warn("No main port, set current port as main port"),p=e,v.find((t=>t===e))||v.push(e)),u.log("Received startSipClient request"),await l.start(r.data),void e.postMessage({type:"workerResponse",requestId:i,response:"OK"});if("request"===r.type){const t=await l.request(r.data);return void e.postMessage({type:"workerResponse",requestId:i,response:t.toString()})}if("reply"===r.type)return await l.reply(r.data),void e.postMessage({type:"workerResponse",requestId:i,response:"OK"});if("register"===r.type)return u.log("Received register request"),await l.register(r.data),void e.postMessage({type:"workerResponse",requestId:i,response:"OK"});if("unregister"===r.type)return u.log("Received unregister request"),await l.dispose(),void e.postMessage({type:"workerResponse",requestId:i,response:"OK"});e.postMessage({type:"workerResponse",requestId:i,response:"NOT_SUPPORTED"})}}else{const s=t.data.state;s&&(Object.keys(s).forEach((t=>{m[t]=s[t]})),v.forEach((t=>{t!==e&&t.postMessage({type:"setSharedState",state:s})})))}}},l.on("inboundMessage",(t=>{let e=p;e||(e=v[0]),e?(u.log("Received inboundMessage, sending to main port"),e.postMessage({type:"inboundMessage",message:t.toString()})):u.warn("No main port, skipping inboundMessage")})),l.on("outboundMessage",(t=>{let e=p;e||(e=v[0]),e?(u.log("Sending outboundMessage to main port"),e.postMessage({type:"outboundMessage",message:t.toString()})):u.warn("No main port, skipping outboundMessage")})),l.on("status",((t,e)=>{u.log("sipClient status changed, sync to ports",t,e),v.forEach((s=>{s.postMessage({type:"status",status:t,error:e})}))})),l.on("transportStatus",(t=>{u.log("sipClient transportStatus changed, sync to ports",t),v.forEach((e=>{e.postMessage({type:"transportStatus",status:t})}))}))}},i={};function r(t){var e=i[t];if(void 0!==e)return e.exports;var n=i[t]={exports:{}};return s[t].call(n.exports,n,n.exports,r),n.exports}r.m=s,r.x=function(){var t=r.O(void 0,[64],(function(){return r(981103)}));return t=r.O(t)},t=[],r.O=function(e,s,i,n){if(!s){var o=1/0;for(u=0;u<t.length;u++){s=t[u][0],i=t[u][1],n=t[u][2];for(var a=!0,c=0;c<s.length;c++)(!1&n||o>=n)&&Object.keys(r.O).every((function(t){return r.O[t](s[c])}))?s.splice(c--,1):(a=!1,n<o&&(o=n));if(a){t.splice(u--,1);var h=i();void 0!==h&&(e=h)}}return e}n=n||0;for(var u=t.length;u>0&&t[u-1][2]>n;u--)t[u]=t[u-1];t[u]=[s,i,n]},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,{a:e}),e},r.d=function(t,e){for(var s in e)r.o(e,s)&&!r.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},r.f={},r.e=function(t){return Promise.all(Object.keys(r.f).reduce((function(e,s){return r.f[s](t,e),e}),[]))},r.u=function(t){return t+".js"},r.miniCssF=function(t){},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},function(){var t;r.g.importScripts&&(t=r.g.location+"");var e=r.g.document;if(!t&&e&&(e.currentScript&&"SCRIPT"===e.currentScript.tagName.toUpperCase()&&(t=e.currentScript.src),!t)){var s=e.getElementsByTagName("script");if(s.length)for(var i=s.length-1;i>-1&&(!t||!/^http(s?):/.test(t));)t=s[i--].src}if(!t)throw new Error("Automatic publicPath is not supported in this browser");t=t.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=t}(),function(){var t={464:1};r.f.i=function(e,s){t[e]||importScripts(r.p+r.u(e))};var e=self.webpackChunkringcentral_embeddable=self.webpackChunkringcentral_embeddable||[],s=e.push.bind(e);e.push=function(e){var i=e[0],n=e[1],o=e[2];for(var a in n)r.o(n,a)&&(r.m[a]=n[a]);for(o&&o(r);i.length;)t[i.pop()]=1;s(e)}}(),e=r.x,r.x=function(){return r.e(64).then(e)};r.x()}();
//# sourceMappingURL=ringcentral-webphone-shared-sip-client.js.map